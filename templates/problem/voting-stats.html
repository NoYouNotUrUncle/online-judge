<style>
    .vote-stats-background{
        background-color: rgb(255,255,255);
        padding: 20px;
        border-radius: 25px;
        justify-content: center;
        align-items: center;
        margin: auto;
        text-align: center;
    }

    .canvas{
        border: 1px;
        border: solid;
        border: #000000;
    }

    .vote-stats-value{
        font-size: 24px;
        font-family: "Segoe UI", "Lucida Grande", Arial, sans-serif;
    }

    .vote-stats-text{
        font-size: 18px;
    }

    .vote-stats-info{
        font-size: 24px;
        font-weight: 500;
        font-family: "Segoe UI", "Lucida Grande", Arial, sans-serif;
        padding: 10px;
    }

    .checkbox{
        width: 20px;
        height: 20px;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      -webkit-transition: .4s;
      transition: .4s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
    }

    input:checked + .slider {
      background-color: #2196F3;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #2196F3;
    }

    input:checked + .slider:before {
      -webkit-transform: translateX(20px);
      -ms-transform: translateX(20px);
      transform: translateX(20px);
    }
</style>

<div class="vote-stats-background" id="id_vote_stats">
    <span class="vote-stats-info">{{ _('Voting Statistics') }}</span>
    <br/>
    <canvas class="canvas" id="id_canvas"></canvas>
    <br/>
    <canvas class="canvas" id="id_canvas2"></canvas>
    <br/>
    {% if has_votes %}
        {% if can_vote %}
            <span class="vote-stats-info">{{ _('Show Votes') }}</span>
            <label class="switch">
                <input class="checkbox" type="checkbox" id="id_show_vote_box" checked="true">
                <span class="slider"></span>
            </label>
        {% endif %}
        <span class="vote-stats-info">{{ _('Show Quartiles') }}</span>
        <label class="switch">
            <input class="checkbox" type="checkbox" id="id_show_quartiles_box" checked="true">
            <span class="slider"></span>
        </label>
        <span class="vote-stats-info">{{ _('Show Mean') }}</span>
        <label class="switch">
            <input class="checkbox" type="checkbox" id="id_show_mean_box" checked="true">
            <span class="slider"></span>
        </label>
        <br/>
        <span class="vote-stats-info">{{ _('Median Vote:') }}</span>
        <span class="vote-stats-value">{{ median_vote|floatformat }}</span>
        <span class="vote-stats-info">{{ _('Mean Vote:') }}</span>
        <span class="vote-stats-value">{{ mean_vote|floatformat }}</span>
        <span class="vote-stats-info">{{ _('Number of Votes:') }}</span>
        <span class="vote-stats-value">{{ num_votes }}</span>
    {% else %}
        <span class="vote-stats-info">{{ _('No Votes Available!') }}</span>
    {% endif %}
</div>
<script>
    const canvas = document.getElementById('id_canvas');
    {% if has_votes %}
        {% if can_vote and all_votes|length > 50 %} //do not render large amounts of votes by default
            document.getElementById('id_show_vote_box').checked = false;
        {% endif %}
        //set canvas size
        const width = 800;
        const height = 300;
        canvas.width = width;
        canvas.height = height;

        //padding around graph area
        const plot_padding = 20;
        const font_size = 14;

        //animation settings and variables
        const animation_duration = 500;
        const ms_per_frame = 25;
        const total_frames = animation_duration/ms_per_frame;
        let frames = 0;
        let animation_started = false;
        //call this function to start the animation (should be called when lightbox opened)
        function startVotingStatsAnimation(){
            animation_started = true;
        }
        //get mouse pointer information when the mouse moves
        let mouse_x = 0;
        let mouse_y = 0;
        document.onmousemove = function(e) {
            const canvas_rect = canvas.getBoundingClientRect();
            const canvas_x = canvas_rect.left;
            const canvas_y = canvas_rect.top;
            mouse_x = e.clientX-canvas_x;
            mouse_y = e.clientY-canvas_y;
        };

        const ctx = canvas.getContext('2d');
        ctx.save();
        //drawing function
        setInterval(function(){
            if (!isOpen(vote_stats_lightbox)) return 0; //do not render if not visible
            //re paint cavas
            ctx.fillStyle = 'rgb(255,255,255)';
            ctx.clearRect(0,0,width,height);
            //range of points to cover
            let points_range = {{ max_vote }}-{{ min_vote }};
            const min_plot_points = Math.max({{ min_vote }}-Math.max(points_range / 4.0, 2), {{ min_possible_vote }});
            const max_plot_points = Math.min({{ max_vote }}+Math.max(points_range / 4.0, 2), {{ max_possible_vote }});
            points_range = max_plot_points - min_plot_points;
            //plot backdrop color
            ctx.fillStyle = 'rgb(255,255,255)';
            const plot_width = width - 2 * plot_padding;
            const plot_height = height - 2 * plot_padding;
            ctx.fillRect(plot_padding, plot_padding, plot_width, plot_height);
            //turn a points value to an x coordinate on the graph
            function points_to_x(points) {
                return plot_padding + plot_width * ((points - min_plot_points) / points_range);
            }

            function line(x1, y1, x2, y2){
                ctx.beginPath();
                ctx.moveTo(x1,y1);
                ctx.lineTo(x2,y2);
                ctx.stroke();
            }

            //draw the vertical lines
            ctx.fillStyle = 'rgb(94,101,105)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = font_size + 'px Arial';
            let points = min_plot_points;
            let points_text_y = height - plot_padding / 2;
            ctx.strokeStyle = 'rgb(94,101,105)';
            ctx.lineWidth = 1;
            let vertical_line_start_y = plot_padding;
            let vertical_line_end_y = plot_padding + plot_height;
            for (let i = 0; i <= 10; i++) {
                line(points_to_x(points), vertical_line_start_y, points_to_x(points), vertical_line_end_y);
                ctx.fillText(points.toFixed(2) + 'p', points_to_x(points), points_text_y);
                points += points_range / 10.0;
            }
            //draw the horizontal lines
            ctx.strokeStyle = 'rgb(94,101,105)';
            let horizontal_line_start_x = plot_padding;
            let horizontal_line_end_x = plot_padding + plot_width;
            let horizontal_line_y = plot_padding;
            for (let i = 0; i <= 4; i++) {
                line(horizontal_line_start_x, horizontal_line_y, horizontal_line_end_x, horizontal_line_y)
                horizontal_line_y += plot_height / 4.0;
            }
            //get the animated x coordinates of a given x based on current frame
            function get_animated_x(final_x) {
                let initial_x = plot_padding + plot_width / 2.0;
                return initial_x + frames * ((final_x - initial_x) / total_frames);
            }

            function points_to_animated_x(points) {
                return get_animated_x(points_to_x(points));
            }

            {% if enough_data_for_plot %} //render box plot
                if (document.getElementById('id_show_quartiles_box').checked) {
                    //box and whisker plot settings
                    const box_plot_height = plot_height * (3 / 4);
                    const box_plot_box_y = plot_padding+plot_height/2-box_plot_height/2;
                    const box_plot_edges_height = plot_height/2;
                    const box_plot_edges_y = plot_padding+plot_height/2-box_plot_edges_height/2;
                    const box_plot_middle_y = plot_padding+plot_height/2;

                    //box and whisker plot data
                    const box_plot_data = [{{min_vote}},{{first_quartile}},{{median_vote}},{{third_quartile}},{{max_vote}}];
                    const render_box_plot = [true,true,true,true,true];
                    for(let i=0;i<2;i++) if(box_plot_data[i] === box_plot_data[i+1]) render_box_plot[i] = false;
                    for(let i=3;i<5;i++) if(box_plot_data[i] === box_plot_data[i-1]) render_box_plot[i] = false;

                    //turning this garbage into for loop, WIP
                    const box_plot_x = [];
                    for (let i = 0; i < 5; i++) box_plot_x.push(points_to_animated_x(box_plot_data[i]));
                    const box_plot_y = [box_plot_edges_y, box_plot_box_y, -1, box_plot_box_y, box_plot_edges_y]

                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 5;
                    for (let i = 0; i < 5; i++){

                    }

                    if (render_box_plot[0]) {//left edge
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[0], box_plot_edges_y);
                        ctx.lineTo(box_plot_x[0], box_plot_edges_y+box_plot_edges_height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[0], box_plot_middle_y);
                        ctx.lineTo(box_plot_x[1], box_plot_middle_y);
                        ctx.stroke();
                    }
                    if (render_box_plot[4]) {//right edge
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[4], box_plot_edges_y);
                        ctx.lineTo(box_plot_x[4], box_plot_edges_y+box_plot_edges_height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[4], box_plot_middle_y);
                        ctx.lineTo(box_plot_x[3], box_plot_middle_y);
                        ctx.stroke();
                    }
                    if (render_box_plot[1]) {//left edge of box
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[1], box_plot_box_y);
                        ctx.lineTo(box_plot_x[2], box_plot_box_y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[1], box_plot_box_y+box_plot_height);
                        ctx.lineTo(box_plot_x[2], box_plot_box_y+box_plot_height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[1], box_plot_box_y);
                        ctx.lineTo(box_plot_x[1], box_plot_box_y+box_plot_height);
                        ctx.stroke();
                    }
                    if (render_box_plot[3]) {//right edge of box
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[3], box_plot_box_y);
                        ctx.lineTo(box_plot_x[2], box_plot_box_y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[3], box_plot_box_y + box_plot_height);
                        ctx.lineTo(box_plot_x[2], box_plot_box_y + box_plot_height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(box_plot_x[3], box_plot_box_y);
                        ctx.lineTo(box_plot_x[3], box_plot_box_y + box_plot_height);
                        ctx.stroke();
                    }
                }
            {% endif %}
            //draw median line
            const median_height = plot_height * (5 / 6);
            const median_y = plot_padding + plot_height / 2 - median_height / 2;
            const median_x = points_to_animated_x({{ median_vote }});
            if (document.getElementById('id_show_quartiles_box').checked) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 5;
                line(median_x, median_y, median_x, median_y + median_height);
            }
            //draw mean line
            const mean_y = median_y;
            const mean_height = median_height;
            const mean_x = points_to_animated_x({{ mean_vote }});
            if (document.getElementById('id_show_mean_box').checked) {
                ctx.strokeStyle = '#00cc00';
                ctx.lineWidth = 5;
                line(mean_x, mean_y, mean_x, mean_y + mean_height);
            }

            {% if can_vote %}
                //draw the individual votes
                if (document.getElementById('id_show_vote_box').checked) {
                    //vote size settings
                    const vote_height = plot_height * (2 / 3);
                    const vote_width = 10;
                    const vote_y = plot_padding + plot_height / 2 - vote_height / 2;
                    //get the votes from context
                    let votes = [];
                    {% for vote in all_votes %}
                        votes.push({{ vote }});
                    {% endfor %}

                    /*
                    votes will have their transparency adjusted based on the maximum amount of
                    overlap with other votes at any given point in the plot
                    e.g. if there is a max overlap of 2, all votes are 50% opaque
                    if there is a max overlap of 4, all votes are 25% opaque
                    doesn't work perfectly in practice because 50% opacity + 50% opacity != 100% opacity,
                    but it provides a nice affect that still makes overlapping votes seem heavier than others
                     */
                    let max_overlap = 0;
                    //use 2 pointers approach to get the maximum number of votes that would overlap on top of each other
                    for (let l = 0, r = 0; l < votes.length; l++) {
                        function next_r_overlaps() {
                            if (r + 1 >= votes.length) return false;
                            const left_vote_x = points_to_animated_x(votes[l]) - vote_width / 2;
                            const right_vote_x = points_to_animated_x(votes[r+1]) - vote_width / 2;
                            return left_vote_x + vote_width >= right_vote_x;
                        }
                        if(r < l) r = l;
                        while (next_r_overlaps()) r++;
                        max_overlap = Math.max(max_overlap, r - l + 1);
                    }

                    let hovered_element = null;

                    //draw the votes
                    for (let i = 0; i < votes.length; i++) {
                        if (i === hovered_element) ctx.fillStyle = 'rgb(0,0,255)'; //different color if mouse is on top
                        else {
                            const transparency = 1/max_overlap;
                            ctx.fillStyle = 'rgb(123,202,255,'+transparency+')';
                        }
                        const vote_x = points_to_animated_x(votes[i]) - vote_width / 2;
                        ctx.fillRect(vote_x, vote_y, vote_width, vote_height);
                    }
                }
            {% endif %}
            //forward animation if incomplete
            if (frames < total_frames && animation_started) frames++
        },ms_per_frame);
    {% else %}
        canvas.hidden = true; //hide canvas
    {% endif %}
</script>