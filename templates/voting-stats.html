<style>
    .vote-stats-background{
        background-color: rgb(255,255,255);
        padding: 20px;
        border-radius: 25px;
        justify-content: center;
        align-items: center;
        margin: auto;
        text-align: center;
    }

    .canvas{
        border: 1px;
        border: solid;
        border: #000000;
    }

    .vote-stats-value{
        font-size: 24px;
    }

    .vote-stats-text{
        font-size: 18px;
    }

    .vote-stats-info{
        font-size: 24px;
        font-weight: bold;
        padding:10px
    }

    .checkbox{
        width: 20px;
        height: 20px;
    }

    .vertical-line{
        border-left: 1px solid black;
        height:50px;
    }
</style>
<div class="vote-stats-background" id="id_vote_stats">
    <span class="vote-stats-info">{{ _('Voting Statistics') }}</span>
    <br/>
    <canvas class="canvas" id="id_canvas"></canvas>
    <br/>
    {% if has_votes %}
        {% if can_vote %}
            <span class="vote-stats-info">{{ _('Show Votes') }}</span>
            <input class="checkbox" type="checkbox" id="id_show_vote_box" checked="true">
            <span class="vertical-line"></span>
        {% endif %}
        <span class="vote-stats-info">{{ _('Show Median') }}</span>
        <input class="checkbox" type="checkbox" id="id_show_median_box" checked="true">
        <span class="vertical-line"></span>
        <span class="vote-stats-info">{{ _('Show Mean') }}</span>
        <input class="checkbox" type="checkbox" id="id_show_mean_box" checked="true">
        {% if enough_data_for_plot %}
            <span class="vertical-line"></span>
            <span class="vote-stats-info">{{ _('Show Box and Whisker Plot') }}</span>
            <input class="checkbox" type="checkbox" id="id_show_box_plot_box" checked="true">
        {% endif %}
        <br/>
        <span class="vote-stats-info">{{ _('Median Vote:') }}</span>
        <span class="vote-stats-value">{{ median_vote|floatformat }}</span>
        <br/>
        <span class="vote-stats-info">{{ _('Mean Vote:') }}</span>
        <span class="vote-stats-value">{{ mean_vote|floatformat }}</span>
    {% else %}
        <span class="vote-stats-info">{{ _('No Votes Available!') }}</span>
    {% endif %}
</div>
<script>
    const canvas = document.getElementById('id_canvas')
    {% if has_votes %}
        {% if can_vote and all_votes|length > 50 %} //do not render large amounts of votes by default
            document.getElementById('id_show_vote_box').checked = false
        {% endif %}
        //set canvas size
        const width = 800
        const height = 300
        canvas.width = width
        canvas.height = height

        //padding around graph area
        const plot_padding = 20
        const font_size = 14

        //animation settings and variables
        const animation_duration = 500
        const ms_per_frame = 25
        const total_frames = animation_duration/ms_per_frame
        let frames = 0
        let animation_started = false
        //call this function to start the animation (should be called when lightbox opened)
        function startVotingStatsAnimation(){
            animation_started = true
        }
        //get mouse pointer information when the mouse moves
        let mouse_x = 0
        let mouse_y = 0
        document.onmousemove = function(e){
            const canvas_rect = canvas.getBoundingClientRect()
            const canvas_x = canvas_rect.left
            const canvas_y = canvas_rect.top
            mouse_x = e.clientX-canvas_x
            mouse_y = e.clientY-canvas_y
        }

        const ctx = canvas.getContext('2d')
        ctx.save()
        //drawing function
        setInterval(function(){
            if(!isOpen(vote_stats_lightbox)) return 0 //do not render if not visible
            //re paint cavas
            ctx.fillStyle = 'rgb(255,255,255)'
            ctx.clearRect(0,0,width,height)
            //range of points to cover
            let points_range = {{ max_vote }}-{{ min_vote }}
            const min_plot_points = Math.max({{ min_vote }}-Math.max(points_range / 4.0, 2), {{ min_possible_vote }})
            const max_plot_points = Math.min({{ max_vote }}+Math.max(points_range / 4.0, 2), {{ max_possible_vote }})
            points_range = max_plot_points - min_plot_points
            //plot backdrop color
            ctx.fillStyle = 'rgb(255,255,255)'
            const plot_width = width - 2 * plot_padding
            const plot_height = height - 2 * plot_padding
            ctx.fillRect(plot_padding, plot_padding, plot_width, plot_height)
            //turn a points value to an x coordinate on the graph
            function points_to_x(points) {
                return plot_padding + plot_width * ((points - min_plot_points) / points_range)
            }
            //draw the vertical lines
            ctx.fillStyle = 'rgb(94,101,105)'
            ctx.textAlign = 'center'
            ctx.textBaseline = 'middle'
            ctx.font = font_size + 'px Arial'
            let points = min_plot_points
            let points_text_y = height - plot_padding / 2
            ctx.strokeStyle = 'rgb(94,101,105)'
            ctx.lineWidth = 1
            let vertical_line_start_y = plot_padding
            let vertical_line_end_y = plot_padding + plot_height
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath()
                ctx.moveTo(points_to_x(points), vertical_line_start_y)
                ctx.lineTo(points_to_x(points), vertical_line_end_y)
                ctx.stroke()
                ctx.fillText(points.toFixed(2) + 'p', points_to_x(points), points_text_y)
                points += points_range / 10.0
            }
            //draw the horizontal lines
            ctx.strokeStyle = 'rgb(94,101,105)'
            let horizontal_line_start_x = plot_padding
            let horizontal_line_end_x = plot_padding + plot_width
            let horizontal_line_y = plot_padding
            for (let i = 0; i <= 4; i++) {
                ctx.beginPath()
                ctx.moveTo(horizontal_line_start_x, horizontal_line_y)
                ctx.lineTo(horizontal_line_end_x, horizontal_line_y)
                ctx.stroke()
                horizontal_line_y += plot_height / 4.0
            }
            //get the animated x coordinates of a given x based on current frame
            function get_animated_x(final_x) {
                let initial_x = plot_padding + plot_width / 2.0
                return initial_x + frames * ((final_x - initial_x) / total_frames)
            }

            function points_to_animated_x(points) {
                return get_animated_x(points_to_x(points))
            }

            {% if enough_data_for_plot %} //render box plot
                if(document.getElementById('id_show_box_plot_box').checked){
                    //box and whisker plot settings
                    const box_plot_height = plot_height * (3 / 4)
                    const box_plot_y = plot_padding+plot_height/2-box_plot_height/2
                    const box_plot_edges_height = plot_height/2
                    const box_plot_edges_y = plot_padding+plot_height/2-box_plot_edges_height/2
                    const box_plot_middle_y = plot_padding+plot_height/2

                    //box and whisker plot data
                    const box_plot_data = [{{min_vote}},{{first_quartile}},{{median_vote}},{{third_quartile}},{{max_vote}}]
                    const render_box_plot = [true,true,true,true,true] //whether or not to render each element
                    if(box_plot_data[3] === box_plot_data[2]) render_box_plot[3] = false
                    if(box_plot_data[4] == box_plot_data[3]) render_box_plot[4] = false
                    if(box_plot_data[1] === box_plot_data[2]) render_box_plot[1] = false
                    if(box_plot_data[0] == box_plot_data[1]) render_box_plot[0] = false

                    const box_plot_x = []
                    for(let i=0;i<5;i++) box_plot_x.push(points_to_animated_x(box_plot_data[i]))

                    ctx.strokeStyle = '#000000'
                    ctx.lineWidth = 5
                    if(render_box_plot[0]){//left edge
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[0],box_plot_edges_y)
                        ctx.lineTo(box_plot_x[0],box_plot_edges_y+box_plot_edges_height)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[0],box_plot_middle_y)
                        ctx.lineTo(box_plot_x[1],box_plot_middle_y)
                        ctx.stroke()
                    }
                    if(render_box_plot[4]){//right edge
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[4],box_plot_edges_y)
                        ctx.lineTo(box_plot_x[4],box_plot_edges_y+box_plot_edges_height)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[4],box_plot_middle_y)
                        ctx.lineTo(box_plot_x[3],box_plot_middle_y)
                        ctx.stroke()
                    }
                    if(render_box_plot[1]){//left edge of box
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[1],box_plot_y)
                        ctx.lineTo(box_plot_x[2],box_plot_y)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[1],box_plot_y+box_plot_height)
                        ctx.lineTo(box_plot_x[2],box_plot_y+box_plot_height)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[1],box_plot_y)
                        ctx.lineTo(box_plot_x[1],box_plot_y+box_plot_height)
                        ctx.stroke()
                    }
                    if(render_box_plot[3]) {//right edge of box
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[3], box_plot_y)
                        ctx.lineTo(box_plot_x[2], box_plot_y)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[3], box_plot_y + box_plot_height)
                        ctx.lineTo(box_plot_x[2], box_plot_y + box_plot_height)
                        ctx.stroke()
                        ctx.beginPath()
                        ctx.moveTo(box_plot_x[3], box_plot_y)
                        ctx.lineTo(box_plot_x[3], box_plot_y + box_plot_height)
                        ctx.stroke()
                    }
                }
            {% endif %}
            //draw median line
            const median_height = plot_height * (5 / 6)
            const median_y = plot_padding + plot_height / 2 - median_height / 2
            const median_x = points_to_animated_x({{ median_vote }})
            if(document.getElementById('id_show_median_box').checked) {
                ctx.strokeStyle = '#ff0000'
                ctx.lineWidth = 5
                ctx.beginPath()
                ctx.moveTo(median_x, median_y)
                ctx.lineTo(median_x, median_y + median_height)
                ctx.stroke()
            }
            //draw mean line
            const mean_y = median_y
            const mean_height = median_height
            const mean_x = points_to_animated_x({{ mean_vote }})
            if(document.getElementById('id_show_mean_box').checked) {
                ctx.strokeStyle = '#00cc00'
                ctx.lineWidth = 5
                ctx.beginPath()
                ctx.moveTo(mean_x, mean_y)
                ctx.lineTo(mean_x, mean_y + mean_height)
                ctx.stroke()
            }

            {% if can_vote %}
                //draw the individual votes
                if (document.getElementById('id_show_vote_box').checked) {
                    //vote size settings
                    const vote_height = plot_height * (2 / 3)
                    const vote_width = 10
                    const vote_y = plot_padding + plot_height / 2 - vote_height / 2
                    //get the votes from context
                    let votes = []
                    {% for vote in all_votes %}
                        votes.push({{ vote }})
                    {% endfor %}

                    /*
                    votes will have their transparency adjusted based on the maximum amount of
                    overlap with other votes at any given point in the plot
                    e.g. if there is a max overlap of 2, all votes are 50% opaque
                    if there is a max overlap of 4, all votes are 25% opaque
                    doesn't work perfectly in practice because 50% opacity + 50% opacity != 100% opacity,
                    but it provides a nice affect that still makes overlapping votes seem heavier than others
                     */
                    let max_overlap = 0
                    //use 2 pointers approach to get the maximum number of votes that would overlap on top of each other
                    for (let l = 0, r = 0; l < votes.length; l++) {
                        function next_r_overlaps() {
                            if (r + 1 >= votes.length) return false
                            const left_vote_x = points_to_animated_x(votes[l]) - vote_width / 2
                            const right_vote_x = points_to_animated_x(votes[r+1]) - vote_width / 2
                            return left_vote_x + vote_width >= right_vote_x
                        }
                        if(r < l) r = l
                        while (next_r_overlaps()) r++;
                        max_overlap = Math.max(max_overlap, r - l + 1)
                    }
                    //check which element user is moving their mouse over
                    //uncomment and use later once who voted is public
                    let hovered_element = null
                    /*
                    for (let i = 0; i < votes.length; i++) {
                        const vote_x = points_to_animated_x(votes[i]) - vote_width / 2
                        if (mouse_x >= vote_x && mouse_x <= vote_x + vote_width && mouse_y >= vote_y && mouse_y <= vote_y + vote_height) {
                            hovered_element = i;
                        }
                    }
                     */
                    //draw the votes
                    for (let i = 0; i < votes.length; i++) {
                        if (i === hovered_element) ctx.fillStyle = 'rgb(0,0,255)' //different color if mouse is on top
                        else {
                            const transparency = 1/max_overlap
                            ctx.fillStyle = 'rgb(123,202,255,'+transparency+')'
                        }
                        const vote_x = points_to_animated_x(votes[i]) - vote_width / 2
                        ctx.fillRect(vote_x, vote_y, vote_width, vote_height)
                    }
                }
            {% endif %}
            //forward animation if incomplete
            if (frames < total_frames && animation_started) frames++
        },ms_per_frame)
    {% else %}
        canvas.hidden = true //hide canvas
    {% endif %}
</script>