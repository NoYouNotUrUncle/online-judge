<style>
    .vote-stats-background{
        background-color: rgb(255,255,255);
        padding: 20px;
        border-radius: 25px;
        justify-content: center;
        align-items: center;
        margin: auto;
        text-align: center;
    }

    .canvas{
        border: 1px;
        border: solid;
        border: #000000;
    }

    .vote-stats-value{
        font-size: 24px;
    }

    .vote-stats-text{
        font-size: 18px;
    }

    .vote-stats-info{
        font-size: 24px;
        font-weight: bold;
        padding:10px
    }
</style>
<div class="vote-stats-background" id="id_vote_stats">
    <span class="vote-stats-info">Voting Statistics</span>
    <br/>
    <canvas class="canvas" id="id_canvas"></canvas>
    <br/>
    <span class="vote-stats-info">footer</span>
    <br/>
    {% if can_vote %}
        <span class="vote-stats-info">Show Votes</span>
        <input type="checkbox" id="id_show_vote_box" checked="true">
    {% endif %}
</div>
<script>
    const canvas = document.getElementById('id_canvas')
    {% if has_votes %}
        const width = 800
        const height = 300
        canvas.width = width
        canvas.height = height

        const ms_per_frame = 50
        const plot_padding = 20
        const font_size = 14

        const total_frames = 20
        let frames = 0
        let animation_started = false
        function startVotingStatsAnimation(){
            animation_started = true
        }

        let mouse_x = 0
        let mouse_y = 0
        document.onmousemove = function(e){
            const canvas_rect = canvas.getBoundingClientRect()
            const canvas_x = canvas_rect.left
            const canvas_y = canvas_rect.top
            mouse_x = e.clientX-canvas_x
            mouse_y = e.clientY-canvas_y
        }

        const ctx = canvas.getContext('2d')
        ctx.save()

        setInterval(function(){
            if(!isOpen(vote_stats_lightbox)) return 0

            console.log('{{ all_votes }}')

            //ctx.restore()
            //ctx.save()

            ctx.fillStyle = 'rgb(255,255,255)'
            ctx.clearRect(0,0,width,height)

            let points_range = {{ max_vote }}-{{ min_vote }}
            const min_plot_points = Math.max({{ min_vote }}-Math.max(points_range / 4.0, 2), {{ min_possible_vote }})
            const max_plot_points = Math.min({{ max_vote }}+Math.max(points_range / 4.0, 2), {{ max_possible_vote }})
            points_range = max_plot_points - min_plot_points

            ctx.fillStyle = 'rgb(255,255,255)'
            const plot_width = width - 2 * plot_padding
            const plot_height = height - 2 * plot_padding
            ctx.fillRect(plot_padding, plot_padding, plot_width, plot_height)

            function points_to_x(points) {
                return plot_padding + plot_width * ((points - min_plot_points) / points_range)
            }

            ctx.fillStyle = 'rgb(94,101,105)'
            ctx.textAlign = 'center'
            ctx.textBaseline = 'middle'
            ctx.font = font_size + 'px Arial'
            let points = min_plot_points
            let points_text_y = height - plot_padding / 2
            ctx.strokeStyle = 'rgb(94,101,105)'
            ctx.lineWidth = 1
            let vertical_line_start_y = plot_padding
            let vertical_line_end_y = plot_padding + plot_height
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath()
                ctx.moveTo(points_to_x(points), vertical_line_start_y)
                ctx.lineTo(points_to_x(points), vertical_line_end_y)
                ctx.stroke()
                ctx.fillText(points.toFixed(2) + 'p', points_to_x(points), points_text_y)

                points += points_range / 10.0
            }

            ctx.strokeStyle = 'rgb(94,101,105)'
            let horizontal_line_start_x = plot_padding
            let horizontal_line_end_x = plot_padding + plot_width
            let horizontal_line_y = plot_padding
            for (let i = 0; i <= 4; i++) {
                ctx.beginPath()
                ctx.moveTo(horizontal_line_start_x, horizontal_line_y)
                ctx.lineTo(horizontal_line_end_x, horizontal_line_y)
                ctx.stroke()
                horizontal_line_y += plot_height / 4.0
            }

            function get_animated_x(final_x) {
                let initial_x = plot_padding + plot_width / 2.0
                return initial_x + frames * ((final_x - initial_x) / total_frames)
            }

            function points_to_animated_x(points) {
                return get_animated_x(points_to_x(points))
            }

            //box and whisker plot
            const box_plot_height = plot_height * (3 / 4)
            const box_plot_y = plot_padding+plot_height/2-box_plot_height/2
            const box_plot_edges_height = plot_height/2
            const box_plot_edges_y = plot_padding+plot_height/2-box_plot_edges_height/2
            const box_plot_middle_y = plot_padding+plot_height/2
            const box_plot_median_height = plot_height*(5/6)
            const box_plot_median_y = plot_padding+plot_height/2-box_plot_middle_y/2

            const box_plot_data = [{{min_vote}},{{first_quartile}},{{median_vote}},{{third_quartile}},{{max_vote}}]
            console.log(box_plot_data)
            const render_box_plot = [true,true,true,true,true]
            if(box_plot_data[3] === box_plot_data[2]) render_box_plot[3] = false
            if(box_plot_data[4] === box_plot_data[2] || box_plot_data[4] == box_plot_data[3]) render_box_plot[4] = false
            if(box_plot_data[1] === box_plot_data[2]) render_box_plot[1] = false
            if(box_plot_data[0] === box_plot_data[2] || box_plot_data[0] == box_plot_data[1]) render_box_plot[0] = false

            const box_plot_x = []
            for(let i=0;i<5;i++) box_plot_x.push(points_to_animated_x(box_plot_data[i]))

            ctx.strokeStyle = '#000000'
            ctx.lineWidth = 5
            if(render_box_plot[0]){
                ctx.beginPath()
                ctx.moveTo(box_plot_x[0],box_plot_edges_y)
                ctx.lineTo(box_plot_x[0],box_plot_edges_y+box_plot_edges_height)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[0],box_plot_middle_y)
                ctx.lineTo(box_plot_x[1],box_plot_middle_y)
                ctx.stroke()
            }
            if(render_box_plot[4]){
                ctx.beginPath()
                ctx.moveTo(box_plot_x[4],box_plot_edges_y)
                ctx.lineTo(box_plot_x[4],box_plot_edges_y+box_plot_edges_height)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[4],box_plot_middle_y)
                ctx.lineTo(box_plot_x[3],box_plot_middle_y)
                ctx.stroke()
            }
            if(render_box_plot[1]){
                ctx.beginPath()
                ctx.moveTo(box_plot_x[1],box_plot_y)
                ctx.lineTo(box_plot_x[2],box_plot_y)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[1],box_plot_y+box_plot_height)
                ctx.lineTo(box_plot_x[2],box_plot_y+box_plot_height)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[1],box_plot_y)
                ctx.lineTo(box_plot_x[1],box_plot_y+box_plot_height)
                ctx.stroke()
            }
            if(render_box_plot[3]){
                ctx.beginPath()
                ctx.moveTo(box_plot_x[3],box_plot_y)
                ctx.lineTo(box_plot_x[2],box_plot_y)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[3],box_plot_y+box_plot_height)
                ctx.lineTo(box_plot_x[2],box_plot_y+box_plot_height)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(box_plot_x[3],box_plot_y)
                ctx.lineTo(box_plot_x[3],box_plot_y+box_plot_height)
                ctx.stroke()
            }

            ctx.strokeStyle = '#ff0000'
            ctx.beginPath()
            ctx.moveTo(box_plot_x[2],box_plot_median_y)
            ctx.lineTo(box_plot_x[2],box_plot_median_y+box_plot_median_height)
            ctx.stroke()

            {% if can_vote %}
                const show_votes_box = document.getElementById('id_show_vote_box')
                if (show_votes_box.checked) {
                    const vote_height = plot_height * (2 / 3)
                    const vote_width = 10
                    const vote_y = plot_padding + plot_height / 2 - vote_height / 2

                    let votes = []
                    {% for vote in all_votes %}
                        votes.push({{ vote }})
                    {% endfor %}

                    let max_overlap = 0
                    //use 2 pointers approach to get the maximum number of votes that would overlap on top of each other
                    //assuming the aforementioned vote width
                    for (let l = 0, r = 0; l < votes.length; l++) {
                        function next_r_overlaps() {
                            if (r + 1 >= votes.length) return false
                            const left_vote_x = points_to_animated_x(votes[l]) - vote_width / 2
                            const right_vote_x = points_to_animated_x(votes[r+1]) - vote_width / 2
                            return left_vote_x + vote_width >= right_vote_x
                        }
                        if(r < l) r = l
                        while (next_r_overlaps()) r++;
                        max_overlap = Math.max(max_overlap, r - l + 1)
                    }

                    let hovered_element = null
                    for (let i = 0; i < votes.length; i++) {
                        const vote_x = points_to_animated_x(votes[i]) - vote_width / 2
                        if (mouse_x >= vote_x && mouse_x <= vote_x + vote_width && mouse_y >= vote_y && mouse_y <= vote_y + vote_height) {
                            hovered_element = i;
                        }
                    }

                    for (let i = 0; i < votes.length; i++) {
                        if (i === hovered_element) ctx.fillStyle = 'rgb(0,0,255)'
                        else {
                            const transparency = 1/max_overlap
                            ctx.fillStyle = 'rgb(123,202,255,'+transparency+')'
                        }
                        const vote_x = points_to_animated_x(votes[i]) - vote_width / 2
                        ctx.fillRect(vote_x, vote_y, vote_width, vote_height)
                    }
                }
            {% endif %}

            if (frames < total_frames && animation_started) frames++
        },ms_per_frame)
    {% else %}
        canvas.hidden = true
    {% endif %}
</script>